.data 
POSICAO_SORVETE: .half 144, 160
A1_intermediario: .word 0
A0_intermediario: .word 0
A2_intermediario: .word 0
A3_intermediario: .word 0


DIRECAO_SORVETE: frente1
ARRAY: .word 0, 0, 0, 0, 0, 0 # array pra fazer a animacao do boneco
SENTIDO: .word 0
CONTADOR_HORIZONTAL: .byte 10
CONTADOR_VERTICAL: .byte 4
NUM: .word 111
NOTAS: 52,1292,50,258,52,258,55,1551,55,258,57,258,59,1551,59,258,60,258,57,2068,47,258,52,1292,50,258,52,258,55,1551,55,258,57,258,59,1551,55,258,62,258,60,2584,52,129,52,258,52,258,52,258,50,129,52,258,53,775,52,129,52,258,52,258,52,258,50,129,52,258,53,775,50,129,50,258,50,258,50,258,50,129,50,258,53,775,48,129,48,258,48,258,48,258,48,129,50,258,48,258,47,516,52,129,52,258,52,258,52,258,50,129,52,258,53,775,52,129,52,258,52,258,52,258,50,129,52,258,53,775,50,129,50,258,50,258,50,258,50,129,50,258,53,775,48,129,48,258,48,258,48,258,48,129,50,258,48,258,47,516,48,129,48,258,48,258,48,258,48,129,50,258,48,258,47,516,48,129,48,258,48,258,48,258,48,129,50,258,48,258,47,516,48,129,48,258,48,258,48,258,48,129,50,258,48,258,47,516,48,129,48,258,48,258,48,258,48,129,50,258,48,258,47,258
NOTA_ATUAL:
ANTIGA_POS_SORVETE: .half 144,160
BLOCOS_P_FIM: .word 0
.include "mapa.data"
.include "frente1.data"
.include "direita1.data"
.include "costas1.data"
.include "esquerda1.data"
.include "bloco_de_neve.data"
.include "bloco_de_gelo.data"
.include "gf1.data"
.include "gf2.data"
.include "gf3.data"
.include "gf4.data"
.include "gf5.data"
.include "gc1.data"
.include "gc2.data"
.include "gc3.data"
.include "gc4.data"
.include "gc5.data"
.include "gd1.data"
.include "gd2.data"
.include "gd3.data"
.include "gd4.data"
.include "gd5.data"
.include "ge1.data"
.include "ge2.data"
.include "ge3.data"
.include "ge4.data"
.include "ge5.data"

.text

##### REGISTRADORES DISPONÍVEIS PARA PROCEDIMENTOS SIMULTÂNEOS AO PRINT:
# 		t6 (é usado na movimentação do personagem)
#		a4
#		a5
#		a6
#		s2
#		s3
#		s4
#		s5
#		s6
#		s7
#		s8
#		s9
#		s10
#		s11




	
	
## Setup da música
SETUP_MUSICA:
		la s0,NUM		# define o endere�o do n�mero de notas
		lw s4,0(s0)		# le o numero de notas
		la s0,NOTAS		# define o endere�o das notas
		li a4,0			# zera o contador de notas
		
		j SETUP
		
#MUSICA:	beq t0,s1, FIM_MUSICA	# contador chegou no final? ent�o  v� para FIM
	#lw s6,0(s3)		# le o valor da nota
	#lw s7,4(s3)		# le a duracao da nota
	#li a7,31		# define a chamada de syscall
	#ecall			# toca a nota
	#mv a0,a1		# passa a dura��o da nota para a pausa
	#li a7,32		# define a chamada de syscal 
	#ecall			# realiza uma pausa de a0 ms
	#addi s3,s3,8		# incrementa para o endere�o da pr�xima nota
	#addi a4,a4,1		# incrementa o contador de notas
#	j MUSICA		# volta ao loop
	
		
		
SETUP:		la a0, mapa
		li a1, 0
		li a2, 0
		li a3, 0
		call PRINT
		li a3, 1
		call PRINT
		
		# carrega o sentido para o qual o personagem est? olhando(inicialmente, para frente)
		la t0, frente1
		la t1, SENTIDO
		sw t0, 0(t1)
		
GAME_LOOP:	call TECLA_PRESS #chama o procedimento que verifica se a tecla est� sendo pressionada
		xori s3,s3,1 #alternador de frames
		
						
		li t0,0xFF200604 # alterador de frames
		sw s3,0(t0)	

		
		la t0,POSICAO_SORVETE #carrega a posicao atual do sorvete em t0
		la t1, SENTIDO
		lw a0, 0(t1) #carrega a sprite do sorvete de acordo com o sentido
		lh a1,0(t0) #carrega a posicao x do sorvete para a1, que é o registrador requisitado pelo procedimento "print"
		lh a2,2(t0) # carrega a posicao y do sorvete para a2, que é o registrador requisitado pelo procedimento "print"
		mv a3,s3 #define o frame utilizado
		call PRINT
		li t0,0xFF200604 # alterador de frames
		sw s3,0(t0)
		
		la t0,ANTIGA_POS_SORVETE
		la a0, bloco_de_neve # geração do personagem
		lh a1,0(t0)
		lh a2,2(t0)
		mv a3,s3
		xori a3, a3, 1
		call PRINT
		
		####reprodução da música
		
		la t6,A2_intermediario #carrega o endereco A2_intermediario em t6
		sw a2,0(t6) #salva o conteudo de a2 em t6
		
		li a2,68		# define o instrumento
		
		la t6,A3_intermediario #carrega o endereco A3_intermediario em t6
		sw a3,0(t6) 		#salva o conteudo de a3 em t6
		
		li a3,50		# define o volume
		
		la t6,A0_intermediario #carrega o endereco A0_intermediario em t6
		sw a0,0(t6) #salva o conteudo de a0 em t6
		la t6,A1_intermediario #carrega o endereco A1_intermediario em t6
		sw a1,0(t6) #carrega o conteudo de a1 em t6
		
		
		lw a0,0(s0)		# le o valor da nota
		lw a1,4(s0)		# le a duracao da nota
		li a7,31		# define a chamada de syscall
		ecall			# toca a nota
		
		addi s0,s0,8		# incrementa para o endere�o da pr�xima nota
		addi a4,a4,1		# incrementa o contador de notas
		
		la t6,A0_intermediario #carrega o enredeco de A0_intermediario em t6
		lw a0,0(t6) #carrega em a0 o conteudo de t6
		la t6,A1_intermediario # carrega o endereco de A1_intermediario em t6
		lw a1,0(t6) #carrega em a0 o conteudo de t6
		la t6,A2_intermediario # carrega o endereco de A1_intermediario em t6
		lw a2,0(t6) #carrega em a0 o conteudo de t6
		la t6,A3_intermediario # carrega o endereco de A1_intermediario em t6
		lw a3,0(t6) #carrega em a0 o conteudo de t6
		
		beq a4,s4,SETUP_MUSICA
		
		
		
		j GAME_LOOP
		
TECLA_PRESS:	li t1,0xFF200000	# carrega o endere�o de controle do KDMMIO
		lw t0,0(t1)			# Le bit de Controle Teclado
		andi t0,t0,0x0001		# mascara o bit menos significativo
	   	beq t0,zero,RETURN   	   	# Se n�o h� tecla pressionada ent�o vai para FIM
	  	lw t2,4(t1)  			# le o valor da tecla tecla
		
		li t0,'w'
		beq t2,t0,ANDA_CIMA #se a tecla pressionada for w, anda para cima
		li t0,'s'
		beq t2,t0,ANDA_BAIXO #se a tecla pressionada for s, anda para baixo
		li t0,'a'
		beq t2,t0,ANDA_ESQ #se a tecla pressionada for a, anda para esquerda
		li t0,'d'
		beq t2,t0,ANDA_DIR #se a tecla pressionada for d, anda para a direita
		li t0, ' '
		beq t2, t0, GELO_ANIMACAO # se for espa�o, mostra o bonequinho cuspindo
		
RETURN:		ret

ANDA_CIMA:	# mudan�a da dire��o p onde o personagem ta olhando
		la t0, costas1
		la t1, SENTIDO # sentido = sprite que vai ser desenhado
		sw t0, 0(t1)

		la t0, CONTADOR_VERTICAL
		lb t1, 0(t0)
		li t2, 14
		beq t1, t2, GAME_LOOP # se a posição y do personagem for igual a 14, o fluxo volta ao game_loop
		
		#verificar se na frente tem gelo ou neve
		la t0, POSICAO_SORVETE
		lh t1, 0(t0) # t1 = posi��o x
		lh t2, 2(t0) # t2 = posi��o y
		addi t2, t2, -16 # pula pro bloco de CIMA
		# trecho do codigo que carrega o primeiro pixel do bloco pra verificar se � gelo ou neve
		li t3, 0xFF0
		add t3, t3, a3
		slli t3, t3, 20
		add t3, t3, t1
		li t4,320
		mul t4, t4, t2
		add t3, t3, t4 # t3 tem o valor do endere�o do pr�ximo quadradinho
		lw t5, 0(t3)
		li t6, 0xe3e3e3e3
		beq t5, t6, GAME_LOOP
		
		#aumento do contador horizontal em 1
		la t0, CONTADOR_VERTICAL
		lb t1, 0(t0)
		addi t1, t1, 1
		sb t1, 0(t0)
		
		la t0,POSICAO_SORVETE

		la t1,ANTIGA_POS_SORVETE #c�digo para salvar a antiga posi��o do personagem e substitu�la por um recorte do fundo
		lw t2,0(t0)
		sw t2,0(t1)
		
		lh t1,2(t0)
		addi t1,t1,-16
		sh t1,2(t0)
		ret				# retorna

ANDA_BAIXO:	# mudan�a da dire��o p onde o personagem ta olhando
		la t0, frente1
		la t1, SENTIDO # sentido = sprite que vai ser desenhado
		sw t0, 0(t1)

		la t0, CONTADOR_VERTICAL
		lb t1, 0(t0)
		beqz t1, GAME_LOOP
		
		#verificar se na frente tem gelo ou neve
		la t0, POSICAO_SORVETE
		lh t1, 0(t0) # t1 = posi��o x
		lh t2, 2(t0) # t2 = posi��o y
		addi t2, t2, 16 # pula pro bloco de baixo
		# trecho do codigo que carrega o primeiro pixel do bloco pra verificar se � gelo ou neve
		li t3, 0xFF0
		add t3, t3, a3
		slli t3, t3, 20
		add t3, t3, t1
		li t4,320
		mul t4, t4, t2
		add t3, t3, t4 # t3 tem o valor do endere�o do pr�ximo quadradinho
		lw t5, 0(t3)
		li t6, 0xe3e3e3e3
		beq t5, t6, GAME_LOOP
		
		#subtra��o do contador horizontal em 1
		la t0, CONTADOR_VERTICAL
		lb t1, 0(t0)
		addi t1, t1, -1
		sb t1, 0(t0)

		la t0,POSICAO_SORVETE
		la t1,ANTIGA_POS_SORVETE #c�digo para salvar a antiga posi��o do personagem e substitu�la por um recorte do fundo
		lw t2,0(t0)
		sw t2,0(t1)
		
		lh t1,2(t0)
		addi t1,t1,16
		sh t1,2(t0)
		ret
		
ANDA_DIR:	# mudan�a da dire��o p onde o personagem ta olhando
		la t0, direita1
		la t1, SENTIDO # sentido = sprite que vai ser desenhado
		sw t0, 0(t1)

		la t0, CONTADOR_HORIZONTAL
		lb t1, 0(t0)
		li t2, 18
		beq t1, t2, GAME_LOOP
		
		#verificar se na frente tem gelo ou neve
		la t0, POSICAO_SORVETE
		lh t1, 0(t0) # t1 = posi��o x
		lh t2, 2(t0) # t2 = posi��o y
		addi t1, t1, 16 # pula pro bloco de CIMA
		# trecho do codigo que carrega o primeiro pixel do bloco pra verificar se � gelo ou neve
		li t3, 0xFF0
		add t3, t3, a3
		slli t3, t3, 20
		add t3, t3, t1
		li t4,320
		mul t4, t4, t2
		add t3, t3, t4 # t3 tem o valor do endere�o do pr�ximo quadradinho
		lw t5, 0(t3)
		li t6, 0xe3e3e3e3
		beq t5, t6, GAME_LOOP

		# aumentar o contador_hoizontal em 1
		la t0, CONTADOR_HORIZONTAL
		lb t1, 0(t0)
		addi t1, t1, 1
		sb t1, 0(t0)

		la t0,POSICAO_SORVETE
		la t1,ANTIGA_POS_SORVETE #c�digo para salvar a antiga posi��o do personagem e substitu�la por um recorte do fundo
		lw t2,0(t0)
		sw t2,0(t1)
		
		lh t1,0(t0)
		addi t1,t1,16
		sh t1,0(t0)
		ret
		
ANDA_ESQ:	# mudan�a da dire��o p onde o personagem ta olhando
		la t0, esquerda1
		la t1, SENTIDO # sentido = sprite que vai ser desenhado
		sw t0, 0(t1)

		la t0, CONTADOR_HORIZONTAL
		lb t1, 0(t0)
		li t2, 3
		beq t1, t2, GAME_LOOP
		
		#verificar se na frente tem gelo ou neve
		la t0, POSICAO_SORVETE
		lh t1, 0(t0) # t1 = posi��o x
		lh t2, 2(t0) # t2 = posi��o y
		addi t1, t1, -16 # pula pro bloco de CIMA
		# trecho do codigo que carrega o primeiro pixel do bloco pra verificar se � gelo ou neve
		li t3, 0xFF0
		add t3, t3, a3
		slli t3, t3, 20
		add t3, t3, t1
		li t4,320
		mul t4, t4, t2
		add t3, t3, t4 # t3 tem o valor do endere�o do pr�ximo quadradinho
		lw t5, 0(t3)
		li t6, 0xe3e3e3e3
		beq t5, t6, GAME_LOOP
		
		# diminuir o contador_hoizontal em 1
		la t0, CONTADOR_HORIZONTAL
		lb t1, 0(t0)
		addi t1, t1, -1
		sb t1, 0(t0)
		
		la t0,POSICAO_SORVETE
		la t1,ANTIGA_POS_SORVETE #c�digo para salvar a antiga posi��o do personagem e substitu�la por um recorte do fundo
		lw t2,0(t0)
		sw t2,0(t1)
		
		lh t1,0(t0)
		addi t1,t1,-16
		sh t1,0(t0)
		ret
						

		 	 			
				
PRINT:		# a0 = endereço da imagem
		# a1 = x_sorvete (coluna)
		# a2 = y_sorvete (linha)
		# a3 = frame (0 ou 1)
		# t0 = endereço do bitmap display
		# t1 = endereço em que a imagem irá ser desenhada
		# t2 = contador da linha
		# t3 = contador da coluna
		# t4 = largura
		# t5 = altura

		li t0, 0xFF0
		add t0, t0, a3
		slli t0, t0, 20
		add t0, t0, a1
		
		li t1, 320
		mul t1, t1, a2
		add t0, t0, t1
		addi t1, a0, 8
		# definição do endereço da imagem
		
		#zerando os contadores
		mv t2, zero 
		mv t3, zero
		
		# definição da largura e da altura
		lw t4, 0(a0)
		lw t5, 4(a0)
		
PRINT_LINHA:	lw t6, 0(t1)
		sw t6, 0(t0) # carrega o pixel na imagem
		
		addi t1, t1, 4 # vai pro proximo pixel
		addi t0, t0, 4
		
		addi t3, t3, 4 # incrementa o contador de coluna
		
		blt t3, t4, PRINT_LINHA # verifica se terminou de desenhar a linha
		
		addi t0, t0,320 # pula p proxima linha
		sub t0, t0, t4 
		
		mv t3, zero # zero o contador de coluna
		addi t2, t2, 1 # 3 incrementa o contador de linha
		bgt t5, t2, PRINT_LINHA
		ret
		
GELO_ANIMACAO:	la t0,SENTIDO
		lw t1, 0(t0)
		la t2, frente1 # verifica qual o sentido que o bonequinho ta olhando
		beq t1, t2, GELO_P_BAIXO
		
		la t2, costas1
		beq t1, t2, GELO_P_CIMA
		
		la t2, esquerda1
		beq t1, t2, GELO_P_ESQ
		
		la t2, direita1
		beq t1, t2, GELO_P_DIR
		ret 
		
GELO_P_BAIXO:	la t0, ARRAY # carregamento dos frames do personagem no array usado na animacao
		la t1, gf1
		sw t1, 0(t0)
		la t1, gf2
		sw t1, 4(t0)
		la t1, gf3
		sw t1, 8(t0)
		la t1, gf4
		sw t1, 12(t0)
		la t1, gf5
		sw t1, 16(t0)
		la t2, SENTIDO
		lw t1, 0(t2)
		sw t1, 20(t0)
		
		la a4, ARRAY
		li a5, 5
		call ANIMACAO

GELO_P_CIMA:	la t0, ARRAY # carregamento dos frames do personagem no array usado na animacao
		la t1, gc1
		sw t1, 0(t0)
		la t1, gc2
		sw t1, 4(t0)
		la t1, gc3
		sw t1, 8(t0)
		la t1, gc4
		sw t1, 12(t0)
		la t1, gc5
		sw t1, 16(t0)
		la t2, SENTIDO
		lw t1, 0(t2)
		sw t1, 20(t0)
		
		la a4, ARRAY
		li a5, 5
		call ANIMACAO


GELO_P_ESQ:	la t0, ARRAY # carregamento dos frames do personagem no array usado na animacao
		la t1, ge1
		sw t1, 0(t0)
		la t1, ge2
		sw t1, 4(t0)
		la t1, ge3
		sw t1, 8(t0)
		la t1, ge4
		sw t1, 12(t0)
		la t1, ge5
		sw t1, 16(t0)
		la t2, SENTIDO
		lw t1, 0(t2)
		sw t1, 20(t0)
		
		la a4, ARRAY
		li a5, 5
		call ANIMACAO


GELO_P_DIR:	la t0, ARRAY # carregamento dos frames do personagem no array usado na animacao
		la t1, gd1
		sw t1, 0(t0)
		la t1, gd2
		sw t1, 4(t0)
		la t1, gd3
		sw t1, 8(t0)
		la t1, gd4
		sw t1, 12(t0)
		la t1, gd5
		sw t1, 16(t0)
		la t2, SENTIDO
		lw t1, 0(t2)
		sw t1, 20(t0)
		
		la a4, ARRAY
		li a5, 5
		call ANIMACAO
		
ANIMACAO:	# anima��o do bonequinho cuspindo o gelo
		xori s3,s3,1 #alternador de frames
		lw  a0, 0(a4)
		la t0, POSICAO_SORVETE
		lh a1, 0(t0)
		lh a2, 2(t0)
		mv a3, s3
		call PRINT
		
		li a7, 32
		li a0, 50
		ecall
		
		li t0,0xFF200604 # alterador de frames
		sw s3,0(t0)
		
		addi a4, a4, 4
		addi a5, a5, -1
		bgtz a5, ANIMACAO
		
		la t0,SENTIDO
		lw t1, 0(t0)
		la t2, frente1 # verifica qual o sentido que o bonequinho ta olhando novamente, para spawnar o gelo
		beq t1, t2, SPAWN_DOWN
		
		la t2, costas1
		beq t1, t2, SPAWN_UP
		
		la t2, esquerda1
		beq t1, t2, SPAWN_LEFT
		
		la t2, direita1
		beq t1, t2, SPAWN_RIGHT
		
SPAWN_DOWN:	#verificar se na frente tem gelo ou neve
		la t0, POSICAO_SORVETE
		lh t1, 0(t0) # t1 = posi��o x
		lh t2, 2(t0) # t2 = posi��o y
		addi t2, t2, 16 # pula pro bloco debaixo
		
		#carregar o conte�do que tem na tela em t3
		# trecho do codigo que carrega o primeiro pixel do bloco pra verificar se � gelo ou neve
		li t3, 0xFF0
		add t3, t3, a3
		slli t3, t3, 20
		add t3, t3, t1
		li t4,320
		mul t4, t4, t2
		add t3, t3, t4 # t3 tem o valor do endere�o do pr�ximo quadradinho
		lw t5, 0(t3)
		
		#verificando se � gelo
		li t4, 0xe3e3e3e3
		beq t4, t5, LOAD_NEVE_D
		
		#verificando se � neve
		li t4, -1
		beq t4, t5, LOAD_GELO_D
		
LOAD_GELO_D: 	xori s3, s3, 1
		la a0, bloco_de_gelo
		la t0, POSICAO_SORVETE
		lh a1, 0(t0)
		lh a2, 2(t0)
		addi a2, a2, 16 # pula pro bloco debaixo
		li a4, 0xe3e3e3e3 # a4 ser� usado para verificar se ainda tem gelo no caminho. caso contrario, o loop se encerra,
				# para que ele n�o quebre todos os gelos da fila/ coluna
		j LOOP_GELO_DOWN
		
LOAD_NEVE_D:	la a0, bloco_de_neve
		la t0, POSICAO_SORVETE
		lh a1, 0(t0)
		lh a2, 2(t0)
		addi a2, a2, 16 # pula pro bloco debaixo
		li a4, -1
		mv a3, s3 # a3 = frame que o gelo sera desenhado	
		
LOOP_GELO_DOWN: li t6, 960 # t6 = posi��o y do final do mapa
		beq a2, t6, GAME_LOOP # verifica se chegou no final do mapa
		
		# trecho do codigo que carrega o primeiro pixel do bloco pra verificar se � gelo ou neve
		# t1 = posi��o x
		# t2 = posi��o y
		li t3, 0xFF0
		add t3, t3, a3
		slli t3, t3, 20
		add t3, t3, a1
		li t4,320
		mul t4, t4, a2
		add t3, t3, t4 # t3 tem o valor do endere�o do pr�ximo quadradinho
		lw t5, 0(t3) # t5 = primeira word de pixels do bloco
		beq t5, a4, GAME_LOOP
		
		xori s3, s3, 1 # muda pro frame que n�o est� sendo desenhado
		mv a3, s3 # a3 = frame que o gelo sera desenhado
		# desenha um bloco no frame 0
		call PRINT
		
		li t0,0xFF200604 # alterador de frames
		sw s3,0(t0)
		
		xori s3,s3,1
		mv a3, s3 # a3 = frame que o gelo sera desenhado
		call PRINT # desenho no frame 1
		
		li t0,0xFF200604 # alterador de frames
		sw s3,0(t0)
		
		addi a2, a2, 16
		j LOOP_GELO_DOWN

SPAWN_UP:	#verificar se na frente tem gelo ou neve
		la t0, POSICAO_SORVETE
		lh t1, 0(t0) # t1 = posi��o x
		lh t2, 2(t0) # t2 = posi��o y
		addi t2, t2, -16 # pula pro bloco de CIMA
		
		#carregar o conte�do que tem na tela em t3
		# trecho do codigo que carrega o primeiro pixel do bloco pra verificar se � gelo ou neve
		li t3, 0xFF0
		add t3, t3, a3
		slli t3, t3, 20
		add t3, t3, t1
		li t4,320
		mul t4, t4, t2
		add t3, t3, t4 # t3 tem o valor do endere�o do pr�ximo quadradinho
		lw t5, 0(t3)
		
		#verificando se � gelo
		li t4, 0xe3e3e3e3
		beq t4, t5, LOAD_NEVE_U
		
		#verificando se � neve
		li t4, -1
		beq t4, t5, LOAD_GELO_U
		
LOAD_GELO_U: 	xori s3, s3, 1
		la a0, bloco_de_gelo
		la t0, POSICAO_SORVETE
		lh a1, 0(t0)
		lh a2, 2(t0)
		addi a2, a2, -16 # pula pro bloco decima
		li a4, 0xe3e3e3e3 # a4 ser� usado para verificar se ainda tem gelo no caminho. caso contrario, o loop se encerra,
				# para que ele n�o quebre todos os gelos da fila/ coluna
		j LOOP_GELO_UP
		
LOAD_NEVE_U:	la a0, bloco_de_neve
		la t0, POSICAO_SORVETE
		lh a1, 0(t0)
		lh a2, 2(t0)
		addi a2, a2, -16 # pula pro bloco decima
		li a4, -1
		mv a3, s3 # a3 = frame que o gelo sera desenhado	
		
LOOP_GELO_UP: 	li t6, -16 # t6 = posi��o y do final do mapa
		beq a2, t6, GAME_LOOP # verifica se chegou no final do mapa
		
		# trecho do codigo que carrega o primeiro pixel do bloco pra verificar se � gelo ou neve
		# t1 = posi��o x
		# t2 = posi��o y
		li t3, 0xFF0
		add t3, t3, a3
		slli t3, t3, 20
		add t3, t3, a1
		li t4,320
		mul t4, t4, a2
		add t3, t3, t4 # t3 tem o valor do endere�o do pr�ximo quadradinho
		lw t5, 0(t3) # t5 = primeira word de pixels do bloco
		beq t5, a4, GAME_LOOP
		
		xori s3, s3, 1 # muda pro frame que n�o est� sendo desenhado
		mv a3, s3 # a3 = frame que o gelo sera desenhado
		# desenha um bloco no frame 0
		call PRINT
		
		li t0,0xFF200604 # alterador de frames
		sw s3,0(t0)
		
		xori s3,s3,1
		mv a3, s3 # a3 = frame que o gelo sera desenhado
		call PRINT # desenho no frame 1
		
		li t0,0xFF200604 # alterador de frames
		sw s3,0(t0)
		
		addi a2, a2, -16
		j LOOP_GELO_UP

SPAWN_RIGHT:	#verificar se na frente tem gelo ou neve
		la t0, POSICAO_SORVETE
		lh t1, 0(t0) # t1 = posi��o x
		lh t2, 2(t0) # t2 = posi��o y
		addi t1, t1, 16 # pula pro bloco de CIMA
		
		#carregar o conte�do que tem na tela em t3
		# trecho do codigo que carrega o primeiro pixel do bloco pra verificar se � gelo ou neve
		li t3, 0xFF0
		add t3, t3, a3
		slli t3, t3, 20
		add t3, t3, t1
		li t4,320
		mul t4, t4, t2
		add t3, t3, t4 # t3 tem o valor do endere�o do pr�ximo quadradinho
		lw t5, 0(t3)
		
		#verificando se � gelo
		li t4, 0xe3e3e3e3
		beq t4, t5, LOAD_NEVE_R
		
		#verificando se � neve
		li t4, -1
		beq t4, t5, LOAD_GELO_R
		
LOAD_GELO_R: 	xori s3, s3, 1
		la a0, bloco_de_gelo
		la t0, POSICAO_SORVETE
		lh a1, 0(t0)
		lh a2, 2(t0)
		addi a1, a1, 16 # pula pro bloco da direita
		li a4, 0xe3e3e3e3 # a4 ser� usado para verificar se ainda tem gelo no caminho. caso contrario, o loop se encerra,
		# para que ele n�o quebre todos os gelos da fila/ coluna
		j LOOP_GELO_R
		
LOAD_NEVE_R:	la a0, bloco_de_neve
		la t0, POSICAO_SORVETE
		lh a1, 0(t0)
		lh a2, 2(t0)
		addi a1, a1, 16 # pula pro bloco da direita
		mv a3, s3 # a3 = frame que o gelo sera desenhado
		li a4, -1
			
		
LOOP_GELO_R: 	li t6, 288 # t6 = posi��o y do final do mapa
		beq a1, t6, GAME_LOOP # verifica se chegou no final do mapa
		
		# trecho do codigo que carrega o primeiro pixel do bloco pra verificar se � gelo ou neve
		# t1 = posi��o x
		# t2 = posi��o y
		li t3, 0xFF0
		add t3, t3, a3
		slli t3, t3, 20
		add t3, t3, a1
		li t4,320
		mul t4, t4, a2
		add t3, t3, t4 # t3 tem o valor do endere�o do pr�ximo quadradinho
		lw t5, 0(t3) # t5 = primeira word de pixels do bloco
		beq t5, a4, GAME_LOOP
		
		xori s3, s3, 1 # muda pro frame que n�o est� sendo desenhado
		mv a3, s3 # a3 = frame que o gelo sera desenhado
		# desenha um bloco no frame 0
		call PRINT
		
		li t0,0xFF200604 # alterador de frames
		sw s3,0(t0)
		
		xori s3,s3,1
		mv a3, s3 # a3 = frame que o gelo sera desenhado
		call PRINT # desenho no frame 1
		
		li t0,0xFF200604 # alterador de frames
		sw s3,0(t0)
		
		addi a1, a1, 16
		j LOOP_GELO_R

SPAWN_LEFT:	#verificar se na frente tem gelo ou neve
		la t0, POSICAO_SORVETE
		lh t1, 0(t0) # t1 = posi��o x
		lh t2, 2(t0) # t2 = posi��o y
		addi t1, t1, -16 # pula pro bloco de CIMA
		
		# trecho do codigo que carrega o primeiro pixel do bloco pra verificar se � gelo ou neve
		#carregar o conte�do que tem na tela em t3
		li t3, 0xFF0
		add t3, t3, a3
		slli t3, t3, 20
		add t3, t3, t1
		li t4,320
		mul t4, t4, t2
		add t3, t3, t4 # t3 tem o valor do endere�o do pr�ximo quadradinho
		lw t5, 0(t3)
		
		#verificando se � gelo
		li t4, 0xe3e3e3e3
		beq t4, t5, LOAD_NEVE_L
		
		#verificando se � neve
		li t4, -1
		beq t4, t5, LOAD_GELO_L
		
LOAD_GELO_L: 	xori s3, s3, 1
		la a0, bloco_de_gelo
		la t0, POSICAO_SORVETE
		lh a1, 0(t0)
		lh a2, 2(t0)
		addi a1, a1, -16 # pula pro bloco da esquerda
		li a4, 0xe3e3e3e3 # a4 ser� usado para verificar se ainda tem gelo no caminho. caso contrario, o loop se encerra,
		# para que ele n�o quebre todos os gelos da fila/ coluna
		j LOOP_GELO_L
		
LOAD_NEVE_L:	la a0, bloco_de_neve
		la t0, POSICAO_SORVETE
		lh a1, 0(t0)
		lh a2, 2(t0)
		addi a1, a1, -16 # pula pro bloco da esquerda
		mv a3, s3 # a3 = frame que o gelo sera desenhado	
		li a4, -1
		
LOOP_GELO_L: 	li t6, 16 # t6 = posi��o y do final do mapa
		beq a1, t6, GAME_LOOP # verifica se chegou no final do mapa
		# trecho do codigo que carrega o primeiro pixel do bloco pra verificar se � gelo ou neve
		# t1 = posi��o x
		# t2 = posi��o y
		li t3, 0xFF0
		add t3, t3, a3
		slli t3, t3, 20
		add t3, t3, a1
		li t4,320
		mul t4, t4, a2
		add t3, t3, t4 # t3 tem o valor do endere�o do pr�ximo quadradinho
		lw t5, 0(t3) # t5 = primeira word de pixels do bloco
		beq t5, a4, GAME_LOOP
		
		xori s3, s3, 1 # muda pro frame que n�o est� sendo desenhado
		mv a3, s3 # a3 = frame que o gelo sera desenhado
		# desenha um bloco no frame 0
		call PRINT
		
		li t0,0xFF200604 # alterador de frames
		sw s3,0(t0)
		
		xori s3,s3,1
		mv a3, s3 # a3 = frame que o gelo sera desenhado
		call PRINT # desenho no frame 1
		
		li t0,0xFF200604 # alterador de frames
		sw s3,0(t0)
		
		addi a1, a1, -16
		j LOOP_GELO_L
